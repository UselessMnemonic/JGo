# JGo
Welcome to JGo, my pet project for bring Go to the JVM! This repo is a running history of my
research and progress. I'm inspired by Kotlin, which shares a lot of similarities to Go and serves
as a proof that many of their similar constructs can work with Java. In the future, an adaptation
of this project will have its basis in Kotlin.

## Mapping Go to Java
### Calling Conventions
In Java, primitives (like `int`, `double`, and `ref`) are passed into functions by their
values alone; this makes them pass-by-value. Java objects (meaning the data comprising object types)
are passed by their references, so objects in Java are _always_ pass-by-reference.

In Go, only maps and channels (meaning the data comprising them) are pass-by-reference. All other
types, like arrays and structs, are pass-by-value. Pointers to such types must be explicitly created
to pass them by reference.

#### Simulating Go Conventions
Java objects can emulate pass-by-value via cloning, so that a new object is constructed when a
distinct copy is needed.

Pass-by-reference, on the other hand, will be achieved by treating all variables in Go as objects.
That is, all variables/fields are treated as non-nullable objects in Java. Similarly, entries of
arrays and slices will also always be non-null and must be modified through these objects.
This minimizes object construction and allows pointers to be generated for any addressable element.

#### The Pointer Class
We introduce a new class called `Pointer` that will work for all orders of references. As the name
implies, it acts as a proxy for the underlying object.
```golang
var a Int
var b Int = 1
a = 5
c := a + b
ptr := &c;
```

```java
Int a = new Int();
Int b = new Int(1);
a.set(5);
Int c = new Int(a.get() + b.get())
Pointer<Int> ptr = new Pointer<Int>(c);
```

### Defined Types
Defined types in Go have their own corresponding types in Java:
```
+------------+------------+
|     GO     |    JAVA    |
+------------+------------+
|            |            |
| (u)int8    | (U)Int8    |
|            |            |
| (u)int16   | (U)Int16   |
|            |            |
| (u)int32   | (U)Int32   |
|            |            |
| (u)int64   | (U)Int64   |
|            |            |
| float32    | Float32    |
|            |            |
| float64    | Float64    |
|            |            |
| complex64  | Complex64  |
|            |            |
| complex128 | Complex128 |
|            |            |
| bool       | Bool       |
|            |            |
| string     | String     |
|            |            |
| [n]T       | Array<T>   |
|            |            |
| []T        | Slice<T>   |
|            |            |
| map[K]V    | Map<K,V>   |
|            |            |
| chan T     | Channel<T> |
|            |            |
| *T         | Pointer<T> |
+------------+------------+
```
...where `String` and `Map` are standard Java classes.

TODO Discuss new type definitions

### Nil and Default Values
Go assigns default values to variables lacking an assignment. For value types like integers, the
default value is `0`; for strings, the empty string; for arrays, an array of defaultly initialized
elements.

Pointers, slices, interfaces, functions, maps, and channels are by default `nil`. A `nil` slice has
0 length and 0 capacity, and a `nil` pointer does not point to anything. `nil` is typed in the sense
that `nil` between types is not comparable (i.e. `(*int)(nil) != (*bool)(nil)`).

### Structs
Structs in Go become independent classes in Java. So, a Go struct declared like this:
```golang
type Item struct {
    Name  String
    Count int
}
```
becomes the following Java class:
```java
public class Item {
   public String Name;
   public int    Count;
}
```
All structs acquire autogenerated implementations of `equals()`, `hashCode()`, and a
deep-copy-constructor.

#### Anonymous Fields
Go allows the user to furnish structs with anonymous fields, fields who take the names of their
types as identifiers. The following Go declaration:
```golang
type Container struct {
    int32
}
```
becomes this Java declaration:
```java
public class Container {
    Int32 Int32;
}
```
The embedded type must be specified with type name `T`, or as a pointer to a non-interface type name
`*T` provided `T` is not a pointer type. In either case, the unqualified type name `T` acts as the
field name.

#### Promoted Fields and Methods
When a struct `A` is anonymously embedded into another struct `B`, the fields and methods of `A`
become _promoted_â€”visible from `B` as if they were its own. Here is a small example:
```golang
type Base struct {
    b int8
}
type Container struct {
    Base         // Base is embedded
}
c := Container{}
c.b = 0          // Base.b is now visible in Container
c.Base.b = 1     // a less succint form of the above line
```
Say `Container` already has its own field `b`. Then the field `Base.b` becomes _shadowed_ by
`Container.b`, accessible only by first accessing the anonymous `Base`:
```golang
type Base struct {
    b int8
}
type Container struct {
    Base         // Base is embedded
    b int8
}
c.b = 0          // Container.b is modified
c.Base.b = 1     // Base.b is modified
```
This amounts to syntactic sugar. For Java, the following declarations are made from the above example:
```java
public class Base {
    Int8 b;
}
public class Container {
    Base Base;
    Int8 b;
}
```

### Functions
Functions have similar mappings to Java as fields and variables. A function declared in Go:
```golang
func doSomething(arg1, arg2 int) string
```
takes its prefix notation form in Java
```java
String doSomething(int arg1, int arg2)
```

#### Multiple Return TODO
Go allows functions to return multiple values at once, but Java does not. To remedy this, functions
that return multiple values instead return a `Tuple`. The `Tuple` is an abstract class, whose
children are any of `Couple`, `Triple`, and so on up to `Septuple` and the general-purpose
`NTuple`. They are immutable POJOs. Here is an example:
```golang
func returnSeveral() (a long, b int)
```
Now here is the Java equivalent:
```java
Couple<Int64, Int32> returnSeveral()
```

#### Anonymous Functions
Go also allows for anonymous functions, which don't have their own names and typically have limited
scope. The Java equivalent is the lambda, which acts like an anonymous function does in Go.

### Method Sets
A Go type may have a method set associated with it. The method set of an interface type is its
interface. The method set of any other type `T` consists of all methods declared with receiver type
`T`. The method set of type `*T` also contains the method set of type `T`.

A Java class representing `T` can have instance methods that reflect those in `T`. Instance methods
can be defined on `T` (or `*T` provided `T` itself is not a pointer type) if those methods are
defined in the same package as `T`.

Since `Pointer`s cannot inherit the methods of their underlying objects, the transpiler
automatically unboxes pointer receivers of a method call.

### Interfaces
All Go interfaces have the same general layout; any Go interface is a tuple consisting of its
dynamic type and its dynamic value.

When an interface is declared, its dynamic type and value are `nil`. This in turn means the
interface value is `nil`. Only when assigned a value do they update to reflect that value. 

#### Interface Methods
In Go, an interface type specifies a method set, called its _interface_. Any type that implements
all the methods of an interface is said to implement that interface.
```golang
type I interface {
    M()
}
```
Any type that has a method `M()` automatically implements interface `I`. Thus, with the following
declaration, `T` implements `I`:
```golang
func (t T) M() {...}
```
This allows a value of type `T` to be passed into a variable of type `I`, like so:
```golang
var t T
var i I = t
```

#### Translating Interfaces
Unfortunately, there is no simple way of translating Go interfaces into Java interfaces. `Pointer`s
can't inherit the interfaces of their underlying values, meaning they cannot be assigned to
variables of interface types. Consider the following Go:
```golang
type Interface interface {
  func Method()
}

type Concrete struct { ... }

func (c Concrete) Method() { ... }

var c  Concrete = Concrete{}
var i1 Interface = c
var i2 Interface = &c
```
We might be tempted to write a similar block in Java:
```java
interface EX {
    void Method();
}

class Concrete implements EX {
    void Method() { ... }
}

Concrete c = new Concrete();
EX e1 = c;
EX e2 = new Pointer<Concrete>(c);
```
...but the glaring issue here is that `Pointer<Concrete>` does not implement `EX`.

#### The Interface Class
To rectify this issue, we introduce a _class_ `Interface<I>`. Assuming `I` is a go interface,
instances of this class can be set to objects that implement `I` or to `Pointer`s whose underlying
values implement `I`.

Now the above example can be written as such:
```java
Concrete c = new Concrete();
Interface<EX> i1 = new Interface(c)
Interface<EX> i2 = new Interface(new Pointer(c))
```
This example can even be extended to pointers _of_ interfaces:
```java
Interface<EX> i3 = new Pointer(i1);
```
### Visibility
#### Packages
Go packages become Java packages, so a Go package `package mypkg` on the path `xyz/` becomes
`xyz.mypkg`. Individual Go files become Java class files, so a file like `example.go` becomes
`ExampleGo.java` and its class is fully qualified as `xyz.mypkg.ExampleGo`.

Functions defined in a Go file become static methods in its corresponding Java class. If the
following is in `example.go`:
```golang
func Square(x int) int
func sqrt(x float32) float32
```
then the following becomes part of `ExampleGo.java`
```java
public class ExampleGo {
    public static int Square(int x);
    static int sqrt(float x);
}
```

#### Identifiers
In Go, identifiers are always visible inside the packages in which they are declared. However, they
are only visible to other packages if those identifiers begin with capital letters. Take the
following example:
```golang
type Address struct {  
    City  string
    State string
    zip   int
}
func (a Address) String() String
func (a Address) transform()
```
The corresponding Java type appears as such:
```java
public class Address implements Stringer {
    public  String City;
    public  String State;
    Int     zip;
    
    public  String String();
    void    transform();
}
```
Therefore, `transform()` and `zip` are visible for the package in which `Address` is defined, but
are not visible anywhere else.

#### Aliases
Aliases are, as their name suggests, aliases. They do not appear in the final Java source.

## Defer, Panic, and Recover
A defer statement pushes a function call onto a list. The list of saved calls is executed after the
surrounding function returns. Defer is commonly used to simplify functions that perform various
clean-up actions. The behavior of defer statements is straightforward and predictable. There are
three simple rules:

1. A deferred function's arguments are evaluated when the defer statement is evaluated.
2. Deferred function calls are executed in Last In First Out order after the surrounding function
   returns.
3. Deferred functions may read and assign to the returning function's named return values.

Defer statements are not available to Java users, since the JVM does not offer any such facility.
They are automatically generated and hence hidden from normal operation.

#### Panic
It is customary in Java to handle errors by throwing exceptions, but Go prefers to make errors part
of function returns. However, some functions that do encounter errors invoke the `panic()` function,
a built-in function that stops the ordinary flow of control and begins panicking.

When a function `F` calls `panic()`, execution of `F` stops, any deferred statements in `F` are
executed normally, and then `F` returns to its caller. To the caller, `F` now behaves like a call to
`panic()`. The process continues up the stack until all functions in the current goroutine have
returned, at which point the program crashes.

Panics translate into runtime exceptions in Java, avoiding the need to declare them in method
declarations. This allows errors to propagate through threads and eventually the JVM, much like
panics.

#### Recover
`recover()` is a built-in function that regains control of a panicking goroutine. `recover()` is
only useful inside deferred functions. During normal execution, a call to `recover()` will return
`nil` and have no other effect. If the current goroutine is panicking, a call to `recover()` will
capture the value given to `panic()` and resume normal execution.

Recovery is not a facility exposed to Java users, like `defer` and `panic()` before it. Instead,
panics must be caught by the user using exception handling, allowing for traditional error
handling. Internally, `recover()` translates into a `try-catch` block that captures the exception.

## Concurrency
### Channels
Channels are powerful tools in Go, allowing for the sharing of memory by communicating. A channel's
type comprises an element type, and a direction of data flow. A channel can be input-only
(`chan<- T`), output-only (`<-chan T`), or bi-directional (`chan T`).

In Java, the channel is represented by the `Channel<T>` class. There are also `InChannel<T>` and
`OutChannel<T>` classes.

Channels can be closed with `close()`. Once closed, attempting to `send()` will cause a panic.
Consumers of the channel can test if a Channel is closed by using either of the following methods:
- `Couple<T,Bool> Channel<T>.receive()`
- `Bool Channel<T>.isClosed()`

A closed channel will yield the zero value of its element type when receiving.

#### Buffered Channels
A buffered channel has a limited capacity for elements. If empty, an attempt to receive from the
channel will block. If full, an attempt to send to the channel will block.

#### Range and Select
The `range` operator on a channel continuously receives from a channel until the channel is closed.
The `select` operator can wait on multiple channels until one is ready. A channel is chosen at
random if multiple are ready.

### Goroutines
Goroutines are Go's solution to parallel computation. Though usually implemented with lightweight
stacks, the JVM will dispatch them to a `ForkJoinPool`.